<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Collections.Immutable</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "T:System.Collections.Generic.HashSetV20`1" -->
        <member name="T:System.Collections.Generic.ISetV20`1">
            <summary>
            Generic collection that guarantees the uniqueness of its elements, as defined
            by some comparer. It also supports basic set operations such as Union, Intersection, 
            Complement and Exclusive Complement.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Implementation Notes:
            Since resizes are relatively expensive (require rehashing), this attempts to minimize 
            the need to resize by setting the initial capacity based on size of collection. 
            </summary>
            <param name="collection"></param>
            <param name="comparer"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Collections.Generic.HashSetV20`1.System#Collections#Generic#ICollection{T}#Add(`0)" -->
        <member name="M:System.Collections.Generic.HashSetV20`1.Clear">
            <summary>
            Remove all items from this set. This clears the elements but not the underlying 
            buckets and slots array. Follow this call by TrimExcess to release these.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.Contains(`0)">
            <summary>
            Checks if this hashset contains the item
            </summary>
            <param name="item">item to check for containment</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy items in this hashset to array, starting at arrayIndex
            </summary>
            <param name="array">array to add items to</param>
            <param name="arrayIndex">index to start at</param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.Remove(`0)">
            <summary>
            Remove item from this hashset
            </summary>
            <param name="item">item to remove</param>
            <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.Add(`0)">
            <summary>
            Add item to this HashSet. Returns bool indicating whether item was added (won't be 
            added if already present)
            </summary>
            <param name="item"></param>
            <returns>true if added, false if already present</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Take the union of this HashSet with other. Modifies this set.
            
            Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
            multiple resizes ended up not being useful in practice; quickly gets to the 
            point where it's a wasteful check.
            </summary>
            <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes the intersection of this set with other. Modifies this set.
            
            Implementation Notes: 
            We get better perf if other is a hashset using same equality comparer, because we 
            get constant contains check in other. Resulting cost is O(n1) to iterate over this.
            
            If we can't go above route, iterate over the other and mark intersection by checking
            contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
            
            Attempts to return early based on counts alone, using the property that the 
            intersection of anything with the empty set is the empty set.
            </summary>
            <param name="other">enumerable with items to add </param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to XOR</param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a subset of other.
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a subset of anything, including the empty set
            2. If other has unique elements according to this equality comparer, and this has more
            elements than other, then it can't be a subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </summary>
            <param name="other"></param>
            <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper subset of other (i.e. strictly contained in)
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a proper subset of a set that contains at least
            one element, but it's not a proper subset of the empty set.
            2. If other has unique elements according to this equality comparer, and this has >=
            the number of elements in other, then this can't be a proper subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </summary>
            <param name="other"></param>
            <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a superset of other
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            2. If other has unique elements according to this equality comparer, and this has less 
            than the number of elements in other, then this can't be a superset
            
            </summary>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper superset of other (i.e. other strictly contained in this)
            
            Implementation Notes: 
            This is slightly more complicated than above because we have to keep track if there
            was at least one element not contained in other.
            
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it can't be a proper superset of any set, even if 
            other is the empty set.
            2. If other is an empty set and this contains at least 1 element, then this is a proper
            superset.
            3. If other has unique elements according to this equality comparer, and other's count
            is greater than or equal to this count, then this can't be a proper superset
            
            Furthermore, if other has unique elements according to this equality comparer, we can
            use a faster element-wise check.
            </summary>
            <param name="other"></param>
            <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.RemoveWhere(System.Predicate{`0})">
            <summary>
            Remove elements that match specified predicate. Returns the number of elements removed
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list (rounded up to nearest prime),
            unless count is 0, in which case we release references.
            
            This method can be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and release all 
            memory referenced by the list, execute the following statements:
            
            list.Clear();
            list.TrimExcess(); 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.CreateSetComparer">
            <summary>
            Used for deep equality of HashSet testing
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.IncreaseCapacity">
            <summary>
            Expand to new capacity. New capacity is next prime greater than or equal to suggested 
            size. This is called when the underlying array is filled. This performs no 
            defragmentation, allowing faster execution; note that this is reasonable since 
            AddIfNotPresent attempts to insert new elements in re-opened spots.
            </summary>
            <param name="sizeSuggestion"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.SetCapacity(System.Int32,System.Boolean)">
            <summary>
            Set the underlying buckets array to size newSize and rehash.  Note that newSize
            *must* be a prime.  It is very likely that you want to call IncreaseCapacity()
            instead of this method.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.AddIfNotPresent(`0)">
            <summary>
            Adds value to HashSet if not contained already
            Returns true if added and false if already present
            </summary>
            <param name="value">value to find</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.ContainsAllElements(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and 
            returns false as soon as it finds an element in other that's not in this.
            Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.IsSubsetOfHashSetWithSameEC(System.Collections.Generic.HashSetV20{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is 
             faster. Simply check that each element in this is in other.
             
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
             
             If callers are concerned about whether this is a proper subset, they take care of that.
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.IntersectWithHashSetWithSameEC(System.Collections.Generic.HashSetV20{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster 
            because we can use other's Contains
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.IntersectWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Iterate over other. If contained in this, mark an element in bit array corresponding to
            its position in m_slots. If anything is unmarked (in bit array), remove it.
            
            This attempts to allocate on the stack, if below StackAllocThreshold.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.InternalIndexOf(`0)">
            <summary>
            Used internally by set operations which have to rely on bit array marking. This is like
            Contains but returns index in slots array. 
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.SymmetricExceptWithUniqueHashSet(System.Collections.Generic.HashSetV20{`0})">
            <summary>
            if other is a set, we can assume it doesn't have duplicate elements, so use this
            technique: if can't remove, then it wasn't present in this set, so add.
            
            As with other methods, callers take care of ensuring that other is a hashset using the
            same equality comparer.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.SymmetricExceptWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Implementation notes:
             
             Used for symmetric except when other isn't a HashSet. This is more tedious because 
             other may contain duplicates. HashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: HashSet technique would add then 
             remove it.
             2. Other has a duplicate that's in this: HashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other. 
             
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.AddOrGetLocation(`0,System.Int32@)">
            <summary>
            Add if not already in hashset. Returns an out param indicating index where added. This 
            is used by SymmetricExcept because it needs to know the following things:
            - whether the item was already present in the collection or added from other
            - where it's located (if already present, it will get marked for removal, otherwise
            marked for keeping)
            </summary>
            <param name="value"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Determines counts that can be used to determine equality, subset, and superset. This
            is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
            these properties can be checked faster without use of marking because we can assume 
            other has no duplicates.
            
            The following count checks are performed by callers:
            1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = m_count; i.e. everything 
            in other is in this and everything in this is in other
            2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = m_count; i.e. other may
            have elements not in this and everything in this is in other
            3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = m_count; i.e
            other must have at least one element not in this and everything in this is in other
            4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
            than m_count; i.e. everything in other was in this and this had at least one element
            not contained in other.
            
            An earlier implementation used delegates to perform these checks rather than returning
            an ElementCount struct; however this was changed due to the perf overhead of delegates.
            </summary>
            <param name="other"></param>
            <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
            because unfoundCount must be 0.</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.ToArray">
            <summary>
            Copies this to an array. Used for DebugView
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.HashSetEquals(System.Collections.Generic.HashSetV20{`0},System.Collections.Generic.HashSetV20{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
            to specified comparer.
            
            Because items are hashed according to a specific equality comparer, we have to resort
            to n^2 search if they're using different equality comparers.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.AreEqualityComparersEqual(System.Collections.Generic.HashSetV20{`0},System.Collections.Generic.HashSetV20{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using 
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetV20`1.InternalGetHashCode(`0)">
            <summary>
            Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
            </summary>
            <param name="item"></param>
            <returns>hash code</returns>
        </member>
        <member name="P:System.Collections.Generic.HashSetV20`1.Count">
            <summary>
            Number of elements in this hashset
            </summary>
        </member>
        <member name="P:System.Collections.Generic.HashSetV20`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Whether this is readonly
            </summary>
        </member>
        <member name="P:System.Collections.Generic.HashSetV20`1.Comparer">
            <summary>
            Gets the IEqualityComparer that is used to determine equality of keys for 
            the HashSet.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.Add(`0)">
            <summary>
            Add the value ITEM to the tree, returns true if added, false if duplicate 
            </summary>
            <param name="item">item to be added</param> 
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.AddIfNotPresent(`0)">
            <summary>
            Adds ITEM to the tree if not already present. Returns TRUE if value was successfully added         
            or FALSE if it is a duplicate
            </summary>        
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.Remove(`0)">
            <summary>
            Remove the T ITEM from this SortedSet. Returns true if successfully removed.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.RotationNeeded(System.Collections.Generic.SortedSetV20{`0}.Node,System.Collections.Generic.SortedSetV20{`0}.Node,System.Collections.Generic.SortedSetV20{`0}.Node)">
            <summary>
            Testing counter that can track rotations
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.CreateSetComparer">
            <summary>
            Used for deep equality of SortedSet testing
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.CreateSetComparer(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a new set comparer for this set, where this set's members' equality is defined by the
            memberEqualityComparer. Note that this equality comparer's definition of equality must be the
            same as this set's Comparer's definition of equality
            </summary>                
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.SortedSetEquals(System.Collections.Generic.SortedSetV20{`0},System.Collections.Generic.SortedSetV20{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Decides whether these sets are the same, given the comparer. If the EC's are the same, we can
            just use SetEquals, but if they aren't then we have to manually check with the given comparer
            </summary>        
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.ToArray">
            <summary>
            Copies this to an array. Used for DebugView
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Transform this set into its union with the IEnumerable OTHER            
            Attempts to insert each element and rejects it if it exists.          
             NOTE: The caller object is important as UnionWith uses the Comparator 
            associated with THIS to check equality                                
             Throws ArgumentNullException if OTHER is null                         
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Transform this set into its intersection with the IEnumerable OTHER     
            NOTE: The caller object is important as IntersectionWith uses the        
            comparator associated with THIS to check equality                        
            Throws ArgumentNullException if OTHER is null                         
            </summary>
            <param name="other"></param>   
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Transform this set into its complement with the IEnumerable OTHER       
             NOTE: The caller object is important as ExceptWith uses the        
             comparator associated with THIS to check equality                        
             Throws ArgumentNullException if OTHER is null                           
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Transform this set so it contains elements in THIS or OTHER but not both
             NOTE: The caller object is important as SymmetricExceptWith uses the        
             comparator associated with THIS to check equality                        
             Throws ArgumentNullException if OTHER is null                           
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks whether this Tree is a subset of the IEnumerable other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks whether this Tree is a proper subset of the IEnumerable other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks whether this Tree is a super set of the IEnumerable other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks whether this Tree is a proper super set of the IEnumerable other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks whether this Tree has all elements in common with IEnumerable other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks whether this Tree has any elements in common with IEnumerable other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            This works similar to HashSet's CheckUniqueAndUnfound (description below), except that the bit
            array maps differently than in the HashSet. We can only use this for the bulk boolean checks.
            
            Determines counts that can be used to determine equality, subset, and superset. This
            is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
            these properties can be checked faster without use of marking because we can assume 
            other has no duplicates.
            
            The following count checks are performed by callers:
            1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = Count; i.e. everything 
            in other is in this and everything in this is in other
            2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = Count; i.e. other may
            have elements not in this and everything in this is in other
            3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = Count; i.e
            other must have at least one element not in this and everything in this is in other
            4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
            than Count; i.e. everything in other was in this and this had at least one element
            not contained in other.
            
            An earlier implementation used delegates to perform these checks rather than returning
            an ElementCount struct; however this was changed due to the perf overhead of delegates.
            </summary>
            <param name="other"></param>
            <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
            because unfoundCount must be 0.</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.GetViewBetween(`0,`0)">
            <summary>
            Returns a subset of this tree ranging from values lBound to uBound
            Any changes made to the subset reflect in the actual tree
            </summary>
            <param name="lowVestalue">Lowest Value allowed in the subset</param>
            <param name="highestValue">Highest Value allowed in the subset</param>        
        </member>
        <member name="T:System.Collections.Generic.SortedSetV20`1.TreeSubSet">
            <summary>
            This class represents a subset view into the tree. Any changes to this view
            are reflected in the actual tree. Uses the Comparator of the underlying tree.
            </summary>
            <typeparam name="T"></typeparam>   
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.TreeSubSet.#ctor">
            <summary>
            For serialization and deserialization
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.TreeSubSet.AddIfNotPresent(`0)">
            <summary>
            Additions to this tree need to be added to the underlying tree as well
            </summary>           
        </member>
        <member name="M:System.Collections.Generic.SortedSetV20`1.TreeSubSet.VersionCheck">
            <summary>
            checks whether this subset is out of date. updates if necessary.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.SortedSetEqualityComparer`1">
            <summary>
            A class that generates an IEqualityComparer for this SortedSet. Requires that the definition of
            equality defined by the IComparer for this SortedSet be consistent with the default IEqualityComparer
            for the type T. If not, such an IEqualityComparer should be provided through the constructor.
            </summary>    
        </member>
        <member name="M:System.Collections.Generic.SortedSetEqualityComparer`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a new SetEqualityComparer, given a comparer for member order and another for member equality (these
            must be consistent in their definition of equality)
            </summary>        
        </member>
        <member name="M:System.Linq.EnumerableV20.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>对 IEnumerable&lt;T&gt;的每个元素执行指定操作</summary>
            <typeparam name="T">IEnumerable&lt;T&gt;序列的元素类型</typeparam>
            <param name="enumerable">IEnumerable&lt;T&gt;序列</param>
            <param name="action">要对IEnumerable&lt;T&gt;的每个元素执行的 Action&lt;T&gt;委托。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="enumerable"/>或<paramref name="action"/>的值为null。</exception>
        </member>
        <member name="M:System.Linq.EnumerableV20.CompareTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
             <summary>
             对两个枚举数进行比较。
             </summary>
             <remarks>
             将对两个枚举数的元素挨个比较。如果任意一次比较不相等，就以该次比较的结果作为最终比较结果。
             如果如此比较到其中一个枚举数的元素已经枚举完毕，那么：
             1.如果另一个枚举数也已枚举完毕，则两者相等；
             2.否则，则以仍有剩余元素者为大。
             </remarks>
             <typeparam name="TSource">枚举的对象的类型</typeparam>
             <param name="x">要比较的第一个枚举数</param>
             <param name="y">要比较的第二个枚举数</param>
             <param name="comparison">比较元素时要使用的 <see cref="T:System.Comparison`1"/></param>
             <returns>一个有符号整数，指示 <paramref name="x"/> 与 <paramref name="y"/> 的相对值，如下表所示。
             <list type="table">
                <listheader>
                    <term>值</term>
                    <description>含义</description>
                </listheader>
                <item>
                    <term>小于0</term>
                    <description><paramref name="x"/>小于<paramref name="y"/></description>
                </item>
                <item>
                    <term>0</term>
                    <description><paramref name="x"/>等于<paramref name="y"/></description>
                </item>
                <item>
                    <term>大于0</term>
                    <description><paramref name="x"/>大于<paramref name="y"/></description>
                </item>
            </list>
             </returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="x"/>, <paramref name="y"/>或<paramref name="comparison"/>等于null。</exception>
             <exception cref="T:System.ArgumentException"><paramref name="comparison"/> 的实现导致比较时出现错误。 例如，将某个项与其自身进行比较时，<paramref name="comparison"/> 可能不返回 0。</exception>
        </member>
        <member name="M:System.Linq.EnumerableV20.CompareTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
             <summary>
             使用指定的比较器对两个枚举数进行比较。
             </summary>
             <remarks>
             将对两个枚举数的元素挨个比较。如果任意一次比较不相等，就以该次比较的结果作为最终比较结果。
             如果如此比较到其中一个枚举数的元素已经枚举完毕，那么：
             1.如果另一个枚举数也已枚举完毕，则两者相等；
             2.否则，则以仍有剩余元素者为大。
             </remarks>
             <typeparam name="TSource">枚举的对象的类型</typeparam>
             <param name="x">要比较的第一个枚举数</param>
             <param name="y">要比较的第二个枚举数</param>
             <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1"/> 实现，或者为null，表示使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default"/></param>
             <returns>一个有符号整数，指示 <paramref name="x"/> 与 <paramref name="y"/> 的相对值，如下表所示。
             <list type="table">
                <listheader>
                    <term>值</term>
                    <description>含义</description>
                </listheader>
                <item>
                    <term>小于0</term>
                    <description><paramref name="x"/>小于<paramref name="y"/></description>
                </item>
                <item>
                    <term>0</term>
                    <description><paramref name="x"/>等于<paramref name="y"/></description>
                </item>
                <item>
                    <term>大于0</term>
                    <description><paramref name="x"/>大于<paramref name="y"/></description>
                </item>
            </list>
             </returns>
             <exception cref="T:System.InvalidOperationException">comparer 为 null，且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default"/> 找不到<typeparamref name="TSource"/> 类型的 <see cref="T:System.IComparable`1"/> 泛型接口或 <see cref="T:System.IComparable"/> 接口的实现。</exception>
             <exception cref="T:System.ArgumentNullException"><paramref name="x"/>或<paramref name="y"/>等于null。</exception>
             <exception cref="T:System.ArgumentException"><paramref name="comparer"/> 的实现导致比较时出现错误。 例如，将某个项与其自身进行比较时，<paramref name="comparer"/> 可能不返回 0。</exception>
        </member>
        <member name="M:System.Linq.EnumerableV20.CompareTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
             <summary>
             对两个枚举数进行比较。
             </summary>
             <remarks>
             将对两个枚举数的元素挨个比较。如果任意一次比较不相等，就以该次比较的结果作为最终比较结果。
             如果如此比较到其中一个枚举数的元素已经枚举完毕，那么：
             1.如果另一个枚举数也已枚举完毕，则两者相等；
             2.否则，则以仍有剩余元素者为大。
             </remarks>
             <typeparam name="TSource">枚举的对象的类型，该类型必须实现<see cref="T:System.IComparable`1"/>接口</typeparam>
             <param name="x">要比较的第一个枚举数</param>
             <param name="y">要比较的第二个枚举数</param>
             <returns>一个有符号整数，指示 <paramref name="x"/> 与 <paramref name="y"/> 的相对值，如下表所示。
             <list type="table">
                <listheader>
                    <term>值</term>
                    <description>含义</description>
                </listheader>
                <item>
                    <term>小于0</term>
                    <description><paramref name="x"/>小于<paramref name="y"/></description>
                </item>
                <item>
                    <term>0</term>
                    <description><paramref name="x"/>等于<paramref name="y"/></description>
                </item>
                <item>
                    <term>大于0</term>
                    <description><paramref name="x"/>大于<paramref name="y"/></description>
                </item>
            </list>
             </returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="x"/>或<paramref name="y"/>等于null。</exception>
        </member>
        <member name="M:System.Linq.EnumerableV20.StartsWith``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            判断第一个枚举数是否以第二个枚举数作为开始部分
            </summary>
            <typeparam name="TSource">枚举的对象的类型，该类型必须实现<see cref="T:System.IEquatable`1"/>接口</typeparam>
            <param name="x">第一个枚举数</param>
            <param name="y">第二个枚举数</param>
            <returns>判断结果</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/>或<paramref name="y"/>为null。</exception>
        </member>
        <member name="M:System.Linq.EnumerableV20.StartsWith``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            判断第一个枚举数是否以第二个枚举数作为开始部分
            </summary>
            <typeparam name="TSource">枚举的对象的类型，该类型必须实现<see cref="T:System.IEquatable`1"/>接口</typeparam>
            <param name="x">第一个枚举数</param>
            <param name="y">第二个枚举数</param>
            <param name="equalityComparer">用于执行相等比较的接口对象</param>
            <returns>判断结果</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/>,<paramref name="y"/>, 或<paramref name="equalityComparer"/>为null。</exception>
        </member>
        <member name="T:System.Linq.SystemCore_EnumerableDebugView`1">
            <summary>
            This class provides the items view for the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:System.Collections.Immutable.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:System.Collections.Immutable.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:System.Collections.Immutable.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:System.Collections.Immutable.Strings.ArrayInitializedStateNotEqual">
            <summary>
              Looks up a localized string similar to Object is not a array with the same initialization state as the array to compare it to..
            </summary>
        </member>
        <member name="P:System.Collections.Immutable.Strings.ArrayLengthsNotEqual">
            <summary>
              Looks up a localized string similar to Object is not a array with the same number of elements as the array to compare it to..
            </summary>
        </member>
        <member name="P:System.Collections.Immutable.Strings.CannotFindOldValue">
            <summary>
              Looks up a localized string similar to Cannot find the old value.
            </summary>
        </member>
        <member name="P:System.Collections.Immutable.Strings.CollectionModifiedDuringEnumeration">
            <summary>
              Looks up a localized string similar to Collection was modified; enumeration operation may not execute..
            </summary>
        </member>
        <member name="P:System.Collections.Immutable.Strings.DuplicateKey">
            <summary>
              Looks up a localized string similar to An element with the same key but a different value already exists..
            </summary>
        </member>
        <member name="P:System.Collections.Immutable.Strings.InvalidEmptyOperation">
            <summary>
              Looks up a localized string similar to This operation does not apply to an empty instance..
            </summary>
        </member>
    </members>
</doc>
